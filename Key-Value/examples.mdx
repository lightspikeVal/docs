---
title: 'Key-Value Store Examples'
description: 'Real-world scenarios and practical examples of using key-value stores in your applications'
icon: 'lightbulb'
---

# Key-Value Store Examples

<Card
  title="Haven't setup yet?"
  icon="plus-circle"
  href="/Key-Value/creation"
  horizontal
>
  Learn how to create your first key-value store and start storing data in minutes.
</Card>

Key-value stores are incredibly versatile and can solve many real-world problems efficiently. Here are practical examples of how to use Purrscale KV stores in different scenarios.

## 1. User Session Management

### Scenario: Web Application Sessions

Manage user sessions across your web application with fast lookups and automatic expiration.

```javascript
// Store user session on login
async function createUserSession(userId, userData) {
  const sessionId = generateSessionId();
  const sessionData = {
    userId,
    email: userData.email,
    role: userData.role,
    loginTime: new Date().toISOString(),
    lastActivity: new Date().toISOString()
  };
  
  // Store session with 24-hour TTL
  await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/sessions`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      key: `sess_${sessionId}`,
      value: JSON.stringify(sessionData),
      metadata: {
        userId,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
      }
    })
  });
  
  return sessionId;
}

// Validate session on each request
async function validateSession(sessionId) {
  const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      bucket: 'sessions',
      key: `sess_${sessionId}`
    })
  });
  
  const result = await response.json();
  if (result.success) {
    const sessionData = JSON.parse(result.data.value);
    
    // Update last activity
    await updateSessionActivity(sessionId);
    return sessionData;
  }
  
  return null;
}
```

**Benefits:**
- Fast session validation (sub-millisecond lookups)
- Automatic cleanup with TTL
- Easy to scale across multiple servers
- Simple to debug and monitor

## 2. User Preferences and Settings

### Scenario: Application Customization

Store user preferences, theme settings, and customization options.

```javascript
// Save user preferences
async function saveUserPreferences(userId, preferences) {
  const prefKey = `user_${userId}_preferences`;
  
  await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/user-preferences`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      key: prefKey,
      value: JSON.stringify({
        theme: preferences.theme || 'light',
        language: preferences.language || 'en',
        notifications: preferences.notifications !== false,
        timezone: preferences.timezone || 'UTC',
        dateFormat: preferences.dateFormat || 'MM/DD/YYYY',
        customSettings: preferences.customSettings || {}
      }),
      metadata: {
        userId,
        lastUpdated: new Date().toISOString(),
        version: '1.0'
      }
    })
  });
}

// Get user preferences with defaults
async function getUserPreferences(userId) {
  const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      bucket: 'user-preferences',
      key: `user_${userId}_preferences`
    })
  });
  
  const result = await response.json();
  
  if (result.success) {
    return JSON.parse(result.data.value);
  }
  
  // Return default preferences
  return {
    theme: 'light',
    language: 'en',
    notifications: true,
    timezone: 'UTC',
    dateFormat: 'MM/DD/YYYY',
    customSettings: {}
  };
}
```

**Benefits:**
- Instant preference loading
- Easy to add new preference options
- User-specific customization
- Default fallback when preferences don't exist

## 3. Feature Flags and A/B Testing

### Scenario: Controlled Feature Rollouts

Manage feature flags for gradual rollouts and A/B testing.

```javascript
// Set up feature flags
async function setFeatureFlag(featureName, enabled, targeting = {}) {
  await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/feature-flags`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      key: `flag_${featureName}`,
      value: JSON.stringify({
        enabled,
        rolloutPercentage: targeting.rolloutPercentage || 100,
        targetUsers: targeting.targetUsers || [],
        targetGroups: targeting.targetGroups || [],
        createdAt: new Date().toISOString(),
        createdBy: 'admin'
      }),
      metadata: {
        featureName,
        environment: process.env.NODE_ENV || 'development'
      }
    })
  });
}

// Check if feature is enabled for user
async function isFeatureEnabled(featureName, userId) {
  const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      bucket: 'feature-flags',
      key: `flag_${featureName}`
    })
  });
  
  const result = await response.json();
  
  if (!result.success) {
    return false; // Default to disabled if flag doesn't exist
  }
  
  const flag = JSON.parse(result.data.value);
  
  // Check if user is specifically targeted
  if (flag.targetUsers.includes(userId)) {
    return flag.enabled;
  }
  
  // Check rollout percentage
  if (flag.rolloutPercentage < 100) {
    const userHash = hashCode(userId + featureName);
    const percentage = (userHash % 100) + 1;
    return percentage <= flag.rolloutPercentage;
  }
  
  return flag.enabled;
}

// Usage in application
async function loadDashboard(userId) {
  const newDashboardEnabled = await isFeatureEnabled('new-dashboard', userId);
  
  if (newDashboardEnabled) {
    return loadNewDashboard();
  } else {
    return loadOldDashboard();
  }
}
```

**Benefits:**
- Instant feature toggling without deployment
- Gradual rollouts to reduce risk
- A/B testing capabilities
- User-specific targeting
- Easy rollback if issues arise

## 4. Rate Limiting and API Throttling

### Scenario: Protect Your API from Abuse

Implement rate limiting to prevent abuse and ensure fair usage.

```javascript
// Track API requests
async function trackApiRequest(apiKey, endpoint) {
  const now = Date.now();
  const windowStart = now - (60 * 1000); // 1 minute window
  const key = `rate_limit_${apiKey}_${endpoint}`;
  
  try {
    // Get current rate limit data
    const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        bucket: 'rate-limits',
        key: key
      })
    });
    
    const result = await response.json();
    let rateData;
    
    if (result.success) {
      rateData = JSON.parse(result.data.value);
      
      // Clean old requests outside the time window
      rateData.requests = rateData.requests.filter(timestamp => timestamp > windowStart);
    } else {
      // Initialize rate data
      rateData = {
        requests: [],
        apiKey,
        endpoint,
        limit: getRateLimitForApiKey(apiKey)
      };
    }
    
    // Check if limit exceeded
    if (rateData.requests.length >= rateData.limit) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }
    
    // Add current request
    rateData.requests.push(now);
    
    // Update rate limit data
    await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/rate-limits`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        key: key,
        value: JSON.stringify(rateData),
        metadata: {
          apiKey,
          endpoint,
          ttl: 300 // 5 minutes TTL
        }
      })
    });
    
    return true;
  } catch (error) {
    console.error('Rate limiting error:', error);
    throw error;
  }
}

// API middleware
async function rateLimitMiddleware(req, res, next) {
  const apiKey = req.headers['x-api-key'];
  const endpoint = req.path;
  
  try {
    await trackApiRequest(apiKey, endpoint);
    next();
  } catch (error) {
    res.status(429).json({
      error: 'Too many requests',
      message: error.message,
      retryAfter: 60
    });
  }
}
```

**Benefits:**
- Prevents API abuse and DDoS attacks
- Fair usage distribution among users
- Configurable limits per API key
- Real-time tracking and enforcement
- Easy to adjust limits as needed

## 5. Shopping Cart Management

### Scenario: E-commerce Platform

Manage shopping carts for users with fast updates and persistence.

```javascript
// Add item to cart
async function addToCart(userId, productId, quantity, options = {}) {
  const cartKey = `cart_${userId}`;
  
  try {
    // Get existing cart
    const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        bucket: 'shopping-carts',
        key: cartKey
      })
    });
    
    let cart;
    const result = await response.json();
    
    if (result.success) {
      cart = JSON.parse(result.data.value);
    } else {
      // Create new cart
      cart = {
        userId,
        items: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
    }
    
    // Check if item already exists
    const existingItemIndex = cart.items.findIndex(item => 
      item.productId === productId && JSON.stringify(item.options) === JSON.stringify(options)
    );
    
    if (existingItemIndex >= 0) {
      // Update quantity
      cart.items[existingItemIndex].quantity += quantity;
    } else {
      // Add new item
      cart.items.push({
        productId,
        quantity,
        options,
        addedAt: new Date().toISOString()
      });
    }
    
    cart.updatedAt = new Date().toISOString();
    
    // Save updated cart
    await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/shopping-carts`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        key: cartKey,
        value: JSON.stringify(cart),
        metadata: {
          userId,
          itemCount: cart.items.length,
          ttl: 86400 // 24 hours TTL
        }
      })
    });
    
    return cart;
  } catch (error) {
    console.error('Error adding to cart:', error);
    throw error;
  }
}

// Get cart with product details
async function getCartWithDetails(userId) {
  const cartKey = `cart_${userId}`;
  
  try {
    const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        bucket: 'shopping-carts',
        key: cartKey
      })
    });
    
    const result = await response.json();
    
    if (!result.success) {
      return { items: [], total: 0 };
    }
    
    const cart = JSON.parse(result.data.value);
    
    // enrich cart items with product details
    const enrichedItems = await Promise.all(
      cart.items.map(async (item) => {
        const product = await getProductDetails(item.productId);
        return {
          ...item,
          product,
          subtotal: product.price * item.quantity
        };
      })
    );
    
    const total = enrichedItems.reduce((sum, item) => sum + item.subtotal, 0);
    
    return {
      ...cart,
      items: enrichedItems,
      total
    };
  } catch (error) {
    console.error('Error getting cart:', error);
    throw error;
  }
}
```

**Benefits:**
- Fast cart updates and retrievals
- Persistent shopping sessions across devices
- Easy to implement cart abandonment recovery
- Real-time inventory management
- Scalable for high-traffic e-commerce sites

## 6. Real-time Leaderboards and Gaming

### Scenario: Gaming Platform Score Tracking

Manage leaderboards, high scores, and player rankings in real-time.

```javascript
// Submit game score
async function submitScore(userId, gameId, score, metadata = {}) {
  const scoreKey = `score_${gameId}_${userId}`;
  const leaderboardKey = `leaderboard_${gameId}`;
  
  try {
    // Store individual score
    await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/game-scores`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        key: scoreKey,
        value: JSON.stringify({
          userId,
          gameId,
          score,
          timestamp: new Date().toISOString(),
          ...metadata
        }),
        metadata: {
          userId,
          gameId,
          ttl: 2592000 // 30 days TTL
        }
      })
    });
    
    // Update leaderboard
    await updateLeaderboard(gameId, userId, score);
    
    return { success: true, message: 'Score submitted successfully' };
  } catch (error) {
    console.error('Error submitting score:', error);
    throw error;
  }
}

// Update leaderboard
async function updateLeaderboard(gameId, userId, score) {
  const leaderboardKey = `leaderboard_${gameId}`;
  
  try {
    // Get current leaderboard
    const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        bucket: 'leaderboards',
        key: leaderboardKey
      })
    });
    
    let leaderboard;
    const result = await response.json();
    
    if (result.success) {
      leaderboard = JSON.parse(result.data.value);
    } else {
      // Initialize new leaderboard
      leaderboard = {
        gameId,
        entries: [],
        lastUpdated: new Date().toISOString()
      };
    }
    
    // Find existing entry or create new one
    const existingEntryIndex = leaderboard.entries.findIndex(entry => entry.userId === userId);
    
    const entry = {
      userId,
      score,
      timestamp: new Date().toISOString(),
      rank: 0 // Will be calculated
    };
    
    if (existingEntryIndex >= 0) {
      // Update only if new score is higher
      if (score > leaderboard.entries[existingEntryIndex].score) {
        leaderboard.entries[existingEntryIndex] = entry;
      }
    } else {
      leaderboard.entries.push(entry);
    }
    
    // Sort by score (descending) and assign ranks
    leaderboard.entries.sort((a, b) => b.score - a.score);
    leaderboard.entries.forEach((entry, index) => {
      entry.rank = index + 1;
    });
    
    // Keep only top 100 entries
    leaderboard.entries = leaderboard.entries.slice(0, 100);
    leaderboard.lastUpdated = new Date().toISOString();
    
    // Save updated leaderboard
    await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/leaderboards`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        key: leaderboardKey,
        value: JSON.stringify(leaderboard),
        metadata: {
          gameId,
          entryCount: leaderboard.entries.length,
          ttl: 86400 // 24 hours TTL
        }
      })
    });
  } catch (error) {
    console.error('Error updating leaderboard:', error);
    throw error;
  }
}

// Get leaderboard
async function getLeaderboard(gameId, limit = 10) {
  const leaderboardKey = `leaderboard_${gameId}`;
  
  try {
    const response = await fetch(`https://kvpawcloud.onrender.com/pawk2/storagekv`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${PURRSCALE_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        bucket: 'leaderboards',
        key: leaderboardKey
      })
    });
    
    const result = await response.json();
    
    if (!result.success) {
      return { entries: [], gameId };
    }
    
    const leaderboard = JSON.parse(result.data.value);
    
    // Get user details for top entries
    const enrichedEntries = await Promise.all(
      leaderboard.entries.slice(0, limit).map(async (entry) => {
        const user = await getUserDetails(entry.userId);
        return {
          ...entry,
          user
        };
      })
    );
    
    return {
      ...leaderboard,
      entries: enrichedEntries
    };
  } catch (error) {
    console.error('Error getting leaderboard:', error);
    throw error;
  }
}
```

**Benefits:**
- Real-time score updates and leaderboard rankings
- Fast top-score queries
- Easy to implement different game modes
- Scalable for multiplayer games
- Persistent score history

## Best Practices for Real-World Usage

### 1. **Use Meaningful Key Names**
```javascript
// Good
const userKey = `user_${userId}_preferences`;
const sessionKey = `sess_${sessionId}`;
const leaderboardKey = `leaderboard_${gameId}`;

// Avoid
const key1 = 'data1';
const key2 = 'user_stuff';
```

### 2. **Implement Proper Error Handling**
```javascript
async function safeKVOperation(operation, fallbackValue = null) {
  try {
    const result = await operation();
    return result;
  } catch (error) {
    if (error.code === 429) {
      // Rate limited - implement backoff
      await new Promise(resolve => setTimeout(resolve, 1000));
      return safeKVOperation(operation, fallbackValue);
    } else if (error.code === 500) {
      // Server error - return fallback
      return fallbackValue;
    } else {
      throw error;
    }
  }
}
```

### 3. **Use TTL for Temporary Data**
```javascript
// Set appropriate TTL values
await fetch(`https://kvpawcloud.onrender.com/pawk2/kv/temp-data`, {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${PURRSCALE_TOKEN}` },
  body: JSON.stringify({
    key: 'temp_session',
    value: 'data',
    metadata: { ttl: 3600 } // 1 hour for sessions
  })
});
```

### 4. **Monitor Usage and Performance**
```javascript
// Track KV operations
async function trackKVOperation(operation, type) {
  const startTime = Date.now();
  
  try {
    const result = await operation();
    const duration = Date.now() - startTime;
    
    // Log metrics
    console.log(`KV ${type} completed in ${duration}ms`);
    return result;
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`KV ${type} failed after ${duration}ms:`, error);
    throw error;
  }
}
```

These examples demonstrate how key-value stores can solve real-world problems efficiently. By leveraging Purrscale's KV stores, you can build scalable, high-performance applications with minimal complexity.
